# -*- coding: utf-8 -*-
"""langgraph-chatbot-with-memory.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gfG5snQES8shu4Sm6J8rV8y3eS1YfI81
"""

!pip install langchain==0.3.25 \
langgraph==0.4.8 \
langchain_openai==0.3.17 \
langgraph-checkpoint-sqlite==2.0.3 \
mypy-ipython==20.8.0 \
grandalf

import os
from getpass import getpass

os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY") or getpass(
    "Enter OpenAI API Key: "
)

from langgraph.graph import START, END, StateGraph, add_messages, MessagesState
from typing_extensions import TypedDict
from langchain_openai.chat_models import ChatOpenAI
from langchain_core.messages import HumanMessage, BaseMessage, AIMessage
from langchain_core.runnables import Runnable
from collections.abc import Sequence
from typing import Literal, Annotated

"""#Add messages (to add context to llm to remember about previous conversations)"""

my_list = add_messages([HumanMessage("Hi! I am Oscar."), AIMessage("Hey Oscar, How can i assist you?")], [HumanMessage("How tall is everest?")])

my_list

"""#Define the state"""

class State(TypedDict):
  messages: Annotated[Sequence[BaseMessage], add_messages] #Added annotated to give more context to Base Message, add_messages will add more context to BaseMessage

"""# Define the nodes"""

chat = ChatOpenAI(model = 'gpt-4o-mini', max_completion_tokens=100)

def chatbot(state: State) -> State:
  print("\n ------------> Entering the chatbot node")
  for i in state["messages"]:
    i.pretty_print()

  response = chat.invoke(state["messages"])
  response.pretty_print()

  return State(messages = [response])

def ask_question(state: State) -> State:
  print("\n ------------> Entering the ask_question node")
  for i in state["messages"]:
    i.pretty_print()

  question = "What is the question?"
  print(question)
  return State(messages = [AIMessage(question), HumanMessage(content = input())])

ask_question(state = State(message = []))

def ask_another_question(state: State) -> State:
  print("\n ------------> Entering the ask_another_question node")
  for i in state["messages"]:
    i.pretty_print()
  question = "Would you wanna ask another question? (yes/no)"

  print(question)

  return State(messages = [AIMessage(question), HumanMessage(content = input())])

"""# define routing function"""

def routing_function(state: State) -> Literal["ask_question", "__end__"]:
  if state["messages"][-1].content == 'yes' :
    return 'ask_question'
  else:
    return '__end__'

"""# Define Graph"""

graph = StateGraph(State)
graph.add_node("ask_question", ask_question)
graph.add_node("chatbot", chatbot)
graph.add_node("ask_another_question", ask_another_question)

graph.add_edge(START, "ask_question")
graph.add_edge("ask_question", "chatbot")
graph.add_edge("chatbot", "ask_another_question")
graph.add_conditional_edges(source = "ask_another_question", path = routing_function)

graph_compiled = graph.compile()

graph_compiled

"""# Test graph"""

graph_compiled.invoke(State(messages = []))